import matplotlib.pyplot as plt, mpld3
from matplotlib import ticker
import pandas as pd
import numpy as np

# For reference: http://benalexkeen.com/parallel-coordinates-in-matplotlib/

# Generates a plot of the inertias generated by the KMeans algorithm in app.py. Was used to make sure kneed was working correctly.
def inertias_plot():
    
    kList = []
    iList = []
    with open('test.txt','r') as infile:

        infile.readline()

        for line in infile:
            line = line.strip()
            splitList = line.split(',')
            kList.append(splitList[0])
            iList.append(splitList[1])
        infile.close()
    
    kList = list(map(int,kList))
    iList = list(map(float,iList))
    iList = [round(x,2) for x in iList]

    plt.plot(kList,iList,'bx-')
    plt.xlabel('k')
    plt.ylabel('inertias')
    plt.xticks(kList)
    plt.show()

def pca_plot():

    df = pd.read_csv('pca.csv')

    plt.plot(df['x'].values,df['y'].values,'bx-')
    plt.xlabel('num components')
    plt.ylabel('(%) variance')
    plt.xticks(df['x'])
    plt.show()


# Creates a parallel coordinate plot using the csv generated by app.py/cluster/<subject_id:int>/<hadm_id:int>
def parallel_plot():


    df = pd.read_csv('cluster.csv')

    # note: begin primitive view
    # df.drop(['AId','SId'],1,inplace=True)
    # pd.plotting.parallel_coordinates(df,'Cluster Label',color=('#51ADC9','#889a00','#F6BFFB'))
    # note: end primitive view

    # note: begin nicer view
    # Get all the column names
    cols = list(df.drop(['AId','SId','Cluster Label'],1,inplace=False).columns.values)
    x = [i for i, _ in enumerate(cols)]
    colors = ['#51ADC9','#889a00','#F6BFFB','#FA0606', '#ECFF0E']

    df.drop(['AId','SId'],1,inplace=True)

    # use the cluster label as a category
    df['Cluster Label'] = df['Cluster Label'].astype('category')

    # create a dict of categories: colors
    colors = { df['Cluster Label'].cat.categories[i]: colors[i] for i, _ in enumerate(df['Cluster Label'].cat.categories) }
    
    fig, axes = plt.subplots(1,len(x)-1, sharey=False, figsize=(15,5))

    min_max_range  = {}
    for col in cols:
        min_max_range[col] = [df[col].min(), df[col].max(), np.ptp(df[col])]
        df[col] = np.true_divide(df[col]-df[col].min(),np.ptp(df[col]))
    
    for i,ax in enumerate(axes):
        for idx in df.index:
            cluster_category = df.loc[idx,'Cluster Label']
            ax.plot(x, df.loc[idx,cols], colors[cluster_category])
        ax.set_xlim([x[i],x[i+1]])
    
    def set_ticks_for_axis(dim, ax, ticks):
        min_val, max_val, val_range = min_max_range[cols[dim]]
        step = val_range / float(ticks-1)
        tick_labels = [round(min_val + step * i, 2) for i in range(ticks)]
        norm_min = df[cols[dim]].min()
        norm_range = np.ptp(df[cols[dim]])
        norm_step = norm_range / float(ticks-1)
        ticks = [round(norm_min + norm_step * i, 2) for i in range(ticks)]
        ax.yaxis.set_ticks(ticks)
        ax.set_yticklabels(tick_labels)

    for dim, ax in enumerate(axes):
        ax.xaxis.set_major_locator(ticker.FixedLocator([dim]))
        set_ticks_for_axis(dim, ax, ticks=6)
        ax.set_xticklabels([cols[dim]])

    ax = plt.twinx(axes[-1])
    dim = len(axes)
    ax.xaxis.set_major_locator(ticker.FixedLocator([x[-2], x[-1]]))
    set_ticks_for_axis(dim, ax, ticks=6)
    ax.set_xticklabels([cols[-2], cols[-1]])

    plt.subplots_adjust(wspace=0)

    # Add legend to plot
    plt.legend( 
    [plt.Line2D((0,1),(0,0), color=colors[cat]) for cat in df['Cluster Label'].cat.categories],
    df['Cluster Label'].cat.categories,
    bbox_to_anchor=(1.2, 1), loc=2, borderaxespad=0.)
    # note: end nicer view

    # mpld3.show()
    plt.show()

parallel_plot()